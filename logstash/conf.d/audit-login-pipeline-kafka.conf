input {
  pipeline {
    address => "audit-login-pipeline-kafka"
  }
}

filter {
  # 로그인에 실패한 로그이면---------------------------------------------------------
  if [auditd][message_type] == "user_login" and [auditd][result] == "fail" {
    mutate {
      # 복잡한 필드 이름을 간단한 이름으로 변경
      rename => {
        "[auditd][message_type]" => "status"
        "[auditd][data][acct]" => "login_id"
        "[host][name]" => "hostname"
        "[source][ip]" => "source_ip"
        "[auditd][data][terminal]" => "method"
        "[auditd][result]" => "result"
        "[host][ip]" => "ip"
      }
    }

    # 로그인 ID가 checkdown인 경우 제거
    if [login_id] == "checkdown" {
      drop{}
    }

    # ip 필드가 배열일 경우 (10.*, 192.*)만 필터링 -> 다른 불필요한 IP 주소는 제외하기 위해서
    ruby {
      code => "
        if event.get('ip') && event.get('ip').is_a?(Array)
          ips = event.get('ip').select { |ip| ip.start_with?('10.', '192.') }
          event.set('ip', ips)
        end
      "
    }

    # 지정된 필드만 유지하고 불필요한 필드는 모두 제거
    prune {
      interpolate => true
      whitelist_names => ["@timestamp", "hostname", "login_id", "source_ip", "method", "result", "ip", "status"]
    }

    # 실패 메시지 설정
    mutate {
      add_field => { "message" => "
🔞[FAILED] '%{login_id}' failed from %{source_ip} to %{hostname} ([%{ip}])
" }
    }
  }

  # 로그인에 성공한 로그이면---------------------------------------------------------
  else if [auditd][message_type] == "user_login" and [auditd][result] == "success" {
    mutate {
      # 복잡한 필드 이름을 간단한 이름으로 변경
      rename => {
        "[auditd][message_type]" => "status"
        "[user][name]" => "login_id"
        "[host][name]" => "hostname"
        "[source][ip]" => "source_ip"
        "[auditd][summary][how]" => "method"
        "[auditd][result]" => "result"
        "[host][ip]" => "ip"
        "[auditd][summary][object][primary]" => "tty"
      }
    }

    # 로그인 ID가 checkdown인 경우 제거
    if [login_id] == "checkdown" {
      drop{}
    }

    # ip 필드가 배열일 경우 (10.*, 192.*)만 필터링 -> 다른 불필요한 IP 주소는 제외하기 위해서
    ruby {
      code => "
        if event.get('ip') && event.get('ip').is_a?(Array)
          ips = event.get('ip').select { |ip| ip.start_with?('10.', '192.') }
          event.set('ip', ips)
        end
      "
    }

    # tty값에서 "/"제거 ex) pts/0 => pts0
    ruby {
      code => '
        if event.get("tty")
          parts = event.get("tty").split("/")
          if parts.length > 2
            event.set("tty", parts[-2] + parts[-1])
          end
        end
      '
    }

    # 지정된 필드만 유지하고 불필요한 필드는 모두 제거
    prune {
      interpolate => true
      whitelist_names => ["@timestamp", "hostname", "login_id", "source_ip", "method", "result", "ip", "tty", "status"]
    }

  }

  # vscode에서 접속했을 경우를 위한 로그---------------------------------------------------------
  else if [auditd][message_type] == "user_start" and [auditd][summary][object][primary] == "ssh" {
    mutate {
      # 복잡한 필드 이름을 간단한 이름으로 변경
      rename => {
        "[auditd][message_type]" => "status"
        "[user][name]" => "login_id"
        "[host][name]" => "hostname"
        "[source][ip]" => "source_ip"
        "[auditd][summary][how]" => "method"
        "[auditd][result]" => "result"
        "[host][ip]" => "ip"
        "[auditd][summary][object][primary]" => "check_vscode"
      }
    }

    # 로그인 ID가 checkdown인 경우 제거
    if [login_id] == "checkdown" {
      drop{}
    }

    # ip 필드가 배열일 경우 (10.*, 192.*)만 필터링 -> 다른 불필요한 IP 주소는 제외하기 위해서
    ruby {
      code => "
        if event.get('ip') && event.get('ip').is_a?(Array)
          ips = event.get('ip').select { |ip| ip.start_with?('10.', '192.') }
          event.set('ip', ips)
        end
      "
    }

    # 지정된 필드만 유지하고 불필요한 필드는 모두 제거
    prune {
      interpolate => true
      whitelist_names => ["@timestamp", "hostname", "login_id", "source_ip", "method", "result", "ip", "check_vscode", "status"]
    }
    
    # 성공 메시지 설정
    mutate {
      add_field => { "message" => "
✅[SUCCESS] '%{login_id}' connected from %{source_ip} to %{hostname} ([%{ip}])
" }
    }
  }

  # 접속을 종료한 로그이면---------------------------------------------------------
  else if [auditd][message_type] == "user_end" {
    # 종료 방식이 /usr/bin/sudo 또는 /usr/sbin/sshd가 아닌 경우 로그 제거
    if [auditd][summary][how] != "/usr/bin/sudo" and [auditd][summary][how] != "/usr/sbin/sshd" {
      drop{}
    } else {
      mutate {
        # 복잡한 필드 이름을 간단한 이름으로 변경
        rename => {
          "[auditd][message_type]" => "status"
          "[user][name]" => "logout_id"
          "[host][name]" => "hostname"
          "[auditd][data][hostname]" => "source_ip"
          "[auditd][summary][how]" => "method"
          "[host][ip]" => "ip"
        }
      }

      # 로그인 ID가 checkdown인 경우 제거
      if [logout_id] == "checkdown" {
        drop{}
      }

      # ip 필드가 배열일 경우 (10.*, 192.*)만 필터링 -> 다른 불필요한 IP 주소는 제외하기 위해서
      ruby {
        code => "
          if event.get('ip') && event.get('ip').is_a?(Array)
            ips = event.get('ip').select { |ip| ip.start_with?('10.', '192.') }
            event.set('ip', ips)
          end
        "
      }

      # 지정된 필드만 유지하고 불필요한 필드는 모두 제거
      prune {
        interpolate => true
        whitelist_names => ["@timestamp", "hostname", "logout_id", "source_ip", "method", "ip", "status"]
      }

    }
  }

  # 그 외에 로그들은 모두 제거
  else {
    drop{}
  }
}

output {
  stdout {
    codec => rubydebug
  }

  # Discord Webhook으로 전송
  if [status] == "user_start" or [result] == "fail" {
    http {
      url => ""
      http_method => "post"
      content_type => "application/json"
      format => "json"
      headers => ["Content-Type", "application/json"]
      mapping => ["content", "%{message}"]
    }
  }

  # Elasticsearch로 전송
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "auditbeat-login-logs-%{+YYYY.MM.dd}"
  }
}

